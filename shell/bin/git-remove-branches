#!/usr/bin/env bash
set -e

# Initialize arrays for branch statuses
branches=()
merged=()
remote_exists=()
contained=()
stale=()

# Determine default branch
default_branch=$(git remote show origin | grep "HEAD branch" | cut -d: -f2 | xargs)
echo "Fetching from origin..."
git fetch origin >/dev/null 2>&1

# Get list of local branches
local_branches=$(git branch --list | cut -c 3-)

# Fetch all remote branches once (much faster than individual ls-remote calls)
remote_branches=$(git ls-remote --heads origin | awk '{print $2}' | sed 's|refs/heads/||')

# Fetch all open PRs once (much faster than individual gh pr list calls)
open_pr_branches=""
if command -v gh >/dev/null 2>&1 && gh auth status >/dev/null 2>&1; then
	echo "Fetching open PRs..."
	open_pr_branches=$(gh pr list --state open --json headRefName --jq '.[].headRefName' 2>/dev/null || echo "")
fi

# Staleness threshold (90 days in seconds)
staleness_threshold=$((90 * 24 * 60 * 60))

# Collect data silently
echo "Analyzing branches..."
for branch in $local_branches; do
	[[ "$branch" == "$default_branch" ]] && continue

	branches+=("$branch")
	idx=$((${#branches[@]} - 1))

	# Check if merged
	set +e
	git branch --merged "$default_branch" | grep -q "^  $branch$"
	merged[$idx]=$?
	set -e

	# Check remote existence (using cached list)
	if echo "$remote_branches" | grep -q "^$branch$"; then
		remote_exists[$idx]=0
	else
		remote_exists[$idx]=1
	fi

	# Check if contained in remote
	set +e
	if [[ ${remote_exists[$idx]} -eq 0 ]]; then
		git merge-base --is-ancestor origin/$branch $branch
		contained[$idx]=$?
	else
		contained[$idx]=1
	fi
	set -e

	# Check staleness
	last_commit_time=$(git log -1 --format="%at" "$branch")
	if (($(date +%s) - last_commit_time > staleness_threshold)); then
		stale[$idx]=1
	else
		stale[$idx]=0
	fi
done

# Display results
echo "Branch Status Summary:"
echo "ğŸŸ¢ Safe to delete   ğŸ”´ Needs review   âš ï¸  Stale   ğŸŒ Remote exists   âœ… Merged"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

safe_branches=()
stale_branches=()
unmerged_branches=()

for i in "${!branches[@]}"; do
	branch="${branches[$i]}"
	status=""

	# Categorize branches
	if [[ ${merged[$i]} -eq 0 ]]; then
		status="ğŸŸ¢"
		safe_branches+=("$branch")
	elif [[ ${stale[$i]} -eq 1 ]]; then
		status="ğŸ”´"
		stale_branches+=("$branch")
	else
		status="ğŸ”´"
		unmerged_branches+=("$branch")
	fi

	# Add placeholder spaces for consistent width
	[[ ${stale[$i]} -eq 1 ]] && status+=" âš ï¸" || status+="   "
	[[ ${remote_exists[$i]} -eq 0 ]] && status+=" ğŸŒ" || status+="   "
	[[ ${merged[$i]} -eq 0 ]] && status+=" âœ…" || status+="   "

	printf "%-12s %s\n" "$status" "$branch"
done

delete_branch() {
	local branch=$1
	local force=$2
	local delete_cmd="-d"
	[[ "$force" == "force" ]] && delete_cmd="-D"

	# Check if remote branch exists using ls-remote
	remote_exists=false
	if git ls-remote --heads origin "$branch" | grep -q "$branch"; then
		remote_exists=true
		echo "Deleting remote branch origin/$branch"
		if ! git push origin --delete "$branch" 2>/dev/null; then
			echo "Warning: Could not delete remote branch $branch (might be already deleted)"
		fi
	fi

	# If remote doesn't exist but we're trying a safe delete, use force delete instead
	# (the branch was already verified as merged to default branch)
	if [[ "$remote_exists" == "false" ]] && [[ "$delete_cmd" == "-d" ]]; then
		delete_cmd="-D"
	fi

	echo "Deleting local branch $branch"
	if ! git branch $delete_cmd "$branch" 2>&1; then
		echo "Warning: Could not delete local branch $branch"
	fi
}

# Function to check if branch has an active PR (using cached list)
has_active_pr() {
	local branch=$1
	if [[ -z "$open_pr_branches" ]]; then
		return 1 # No PR data available
	fi

	if echo "$open_pr_branches" | grep -q "^${branch}$"; then
		return 0 # Has active PR
	fi
	return 1 # No active PR
}

# Handle safe branches
if [[ ${#safe_branches[@]} -gt 0 ]]; then
	echo -e "\nğŸŸ¢ Safe to delete:"
	printf '%s\n' "${safe_branches[@]}" | sed 's/^/  ğŸŸ¢ /'
	read -r -p "Delete these local and remote branches? (y/N) " confirm
	if [[ "$confirm" == "y" ]]; then
		for branch in "${safe_branches[@]}"; do
			delete_branch "$branch"
		done
	fi
fi

# Handle stale branches
if [[ ${#stale_branches[@]} -gt 0 ]]; then
	echo -e "\nâš ï¸  Stale branches:"
	printf '%s\n' "${stale_branches[@]}" | sed 's/^/  âš ï¸  /'
	read -r -p "Delete these stale local and remote branches? (y/N) " confirm
	if [[ "$confirm" == "y" ]]; then
		for branch in "${stale_branches[@]}"; do
			delete_branch "$branch" force
		done
	fi
fi

# Handle unmerged branches
if [[ ${#unmerged_branches[@]} -gt 0 ]]; then
	echo -e "\nğŸ”´ Unmerged branches:"
	active_prs=()
	other_unmerged=()

	for branch in "${unmerged_branches[@]}"; do
		if has_active_pr "$branch"; then
			active_prs+=("$branch")
		else
			other_unmerged+=("$branch")
		fi
	done

	if [[ ${#active_prs[@]} -gt 0 ]]; then
		echo -e "\nğŸ“ Branches with active PRs (skipping):"
		printf '%s\n' "${active_prs[@]}" | sed 's/^/  ğŸ”´ /'
	fi

	if [[ ${#other_unmerged[@]} -gt 0 ]]; then
		echo -e "\nğŸ”´ Unmerged branches without active PRs:"
		printf '%s\n' "${other_unmerged[@]}" | sed 's/^/  ğŸ”´ /'
		read -r -p "Force delete these unmerged local and remote branches? (y/N) " confirm
		if [[ "$confirm" == "y" ]]; then
			for branch in "${other_unmerged[@]}"; do
				delete_branch "$branch" force
			done
		fi
	fi
fi
